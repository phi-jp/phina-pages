<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">
phina.namespace(function() {

<span id='phina-display-Shape'>  /**
</span>   * @class phina.display.Shape
   *
   */
  phina.define(&#39;phina.display.Shape&#39;, {
    superClass: &#39;phina.display.CanvasElement&#39;,

    init: function(options) {
      options = (options || {}).$safe({
        width: 64,
        height: 64,
        padding: 8,

        backgroundColor: &#39;#aaa&#39;,
        fill: &#39;#00a&#39;,
        stroke: &#39;#aaa&#39;,
        strokeWidth: 4,

        shadow: false,
        shadowBlur: 4,
      });
      this.superInit(options);

      this.padding = options.padding;

      this.backgroundColor = options.backgroundColor;
      this.fill = options.fill;
      this.stroke = options.stroke;
      this.strokeWidth = options.strokeWidth;

      this.shadow = options.shadow;
      this.shadowBlur = options.shadowBlur;

      this.canvas = phina.graphics.Canvas();
      this._dirtyDraw = true;

      this.on(&#39;enterframe&#39;, function() {
        if (this._dirtyDraw === true) {
          this._render();
          this._dirtyDraw = false;
        }
      });
    },

    _render: function() {
      this._renderBackground();

      return this;
    },

    _renderBackground: function(width, height, color) {
      width = width || (this.width + this.padding*2);
      height = height || (this.height + this.padding*2);
      color = color || this.backgroundColor;

      this.canvas.width = width;
      this.canvas.height= height;
      this.canvas.clearColor(color);

      return this;
    },

    draw: function(canvas) {
      var image = this.canvas.domElement;
      var w = image.width;
      var h = image.height;

      // var x = -this.width*this.originX - this.padding;
      // var y = -this.height*this.originY - this.padding;
      var x = -w*this.origin.x;
      var y = -h*this.origin.y;

      canvas.context.drawImage(image,
        0, 0, w, h,
        x, y, w, h
        );
    },

    _accessor: {
      width: {
        get: function() {
          return (this.boundingType === &#39;rect&#39;) ?
            this._width : this._diameter;
        },
        set: function(v) {
          this._dirtyDraw = true; this._width = v;
        },
      },
      height: {
        get: function() {
          return (this.boundingType === &#39;rect&#39;) ?
            this._height : this._diameter;
        },
        set: function(v) {
          this._dirtyDraw = true; this._height = v;
        },
      },
      radius: {
        &quot;get&quot;: function()   {
          return (this.boundingType === &#39;rect&#39;) ?
            (this.width+this.height)/4 : this._radius;
        },
        &quot;set&quot;: function(v)  {
          this._dirtyDraw = true;
          this._radius = v;
          this._diameter = v*2;
        },
      },
      padding: {
        get: function() {
          return this._padding;
        },
        set: function(v) {
          this._dirtyDraw = true; this._padding = v;
        },
      },
      backgroundColor: {
        get: function() {
          return this._backgroundColor;
        },
        set: function(v) {
          this._dirtyDraw = true;
          this._backgroundColor = v;
        },
      },
      fill: {
        get: function() {
          return this._fill;
        },
        set: function(v) {
          this._dirtyDraw = true;
          this._fill = v;
        },
      },
      stroke: {
        get: function() {
          return this._stroke;
        },
        set: function(v) {
          this._dirtyDraw = true;
          this._stroke = v;
        },
      },
      strokeWidth: {
        get: function() {
          return this._strokeWidth;
        },
        set: function(v) {
          this._dirtyDraw = true;
          this._strokeWidth = v;
        },
      },
      shadow: {
        get: function() {
          return this._shadow;
        },
        set: function(v) {
          this._dirtyDraw = true;
          this._shadow = v;
        },
      },
      shadowBlur: {
        get: function() {
          return this._shadowBlur;
        },
        set: function(v) {
          this._dirtyDraw = true;
          this._shadowBlur = v;
        },
      },
    },
  });

});

phina.namespace(function() {
<span id='phina-display-RectangleShape'>  /**
</span>   * @class phina.display.RectangleShape
   *
   */
  phina.define(&#39;phina.display.RectangleShape&#39;, {
    superClass: &#39;phina.display.Shape&#39;,
    init: function(options) {

      options = (options || {}).$safe({
        backgroundColor: &#39;transparent&#39;,
        fill: &#39;blue&#39;,
        stroke: &#39;#aaa&#39;,
        strokeWidth: 4,

        cornerRadius: 0,
      });
      this.superInit(options);

      this.cornerRadius = options.cornerRadius;
    },

    _render: function() {
      this._renderBackground();

      this.canvas.transformCenter();

      if (this.fill) {
        this.canvas.context.fillStyle = this.fill;
        this.canvas.fillRoundRect(-this.width/2, -this.height/2, this.width, this.height, this.cornerRadius);
      }

      if (this.stroke) {
        this.canvas.context.lineWidth = this.strokeWidth;
        this.canvas.strokeStyle = this.stroke;
        this.canvas.strokeRoundRect(-this.width/2, -this.height/2, this.width, this.height, this.cornerRadius);
      }
    },

    _accessor: {
      cornerRadius: {
        get: function() {
          return this._cornerRadius;
        },
        set: function(v) {
          this._dirtyDraw = true; this._cornerRadius = v;
        },
      }
    },
  });
});

phina.namespace(function() {

<span id='phina-display-CircleShape'>  /**
</span>   * @class phina.display.CircleShape
   *
   */
  phina.define(&#39;phina.display.CircleShape&#39;, {
    superClass: &#39;phina.display.Shape&#39;,
    init: function(options) {
      options = (options || {}).$safe({
        backgroundColor: &#39;transparent&#39;,
        fill: &#39;red&#39;,
        stroke: &#39;#aaa&#39;,
        strokeWidth: 4,
        radius: 32,
      });
      this.superInit(options);

      this.setBoundingType(&#39;circle&#39;);
    },

    _render: function() {
      var size = this.radius*2 + this.padding*2;
      this._renderBackground(size, size);

      this.canvas.transformCenter();

      if (this.fill) {
        this.canvas.context.fillStyle = this.fill;
        this.canvas.fillCircle(0, 0, this.radius);
      }

      if (this.stroke) {
        this.canvas.context.lineWidth = this.strokeWidth;
        this.canvas.strokeStyle = this.stroke;
        this.canvas.strokeCircle(0, 0, this.radius);
      }
    },
  });
});

phina.namespace(function() {
<span id='phina-display-TriangleShape'>  /**
</span>   * @class phina.display.TriangleShape
   *
   */
  phina.define(&#39;phina.display.TriangleShape&#39;, {
    superClass: &#39;phina.display.Shape&#39;,
    init: function(options) {
      options = (options || {}).$safe({
        backgroundColor: &#39;transparent&#39;,
        fill: &#39;green&#39;,
        stroke: &#39;#aaa&#39;,
        strokeWidth: 4,

        radius: 32,
      });
      this.superInit(options);

      this.setBoundingType(&#39;circle&#39;);
    },

    _render: function() {
      var size = this.radius*2 + this.padding*2;
      this._renderBackground(size, size);

      var canvas = this.canvas;

      canvas.transformCenter();

      if (this.fill) {
        canvas.context.fillStyle = this.fill;
        canvas.fillPolygon(0, 0, this.radius, 3);
      }

      if (this.stroke) {
        canvas.context.lineWidth = this.strokeWidth;
        canvas.strokeStyle = this.stroke;
        canvas.strokePolygon(0, 0, this.radius, 3);
      }
    },
  });

});

phina.namespace(function() {
<span id='phina-display-StarShape'>  /**
</span>   * @class phina.display.StarShape
   *
   */
  phina.define(&#39;phina.display.StarShape&#39;, {
    superClass: &#39;phina.display.Shape&#39;,
    init: function(options) {
      options = (options || {}).$safe({
        backgroundColor: &#39;transparent&#39;,
        fill: &#39;yellow&#39;,
        stroke: &#39;#aaa&#39;,
        strokeWidth: 4,

        radius: 32,
        sides: 5,
        sideIndent: 0.38,
      });
      this.superInit(options);

      this.setBoundingType(&#39;circle&#39;);
      this.sides = options.sides;
      this.sideIndent = options.sideIndent;
    },

    _render: function() {
      var size = this.radius*2 + this.padding*2;
      this._renderBackground(size, size);

      var canvas = this.canvas;

      canvas.transformCenter();

      if (this.fill) {
        canvas.context.fillStyle = this.fill;
        canvas.fillStar(0, 0, this.radius, this.sides, this.sideIndent);
      }

      if (this.stroke) {
        canvas.context.lineWidth = this.strokeWidth;
        canvas.strokeStyle = this.stroke;
        canvas.strokeStar(0, 0, this.radius, this.sides, this.sideIndent);
      }
    },

    _accessor: {
      sides: {
        get: function() { return this._sides; },
        set: function(v) { this._dirtyDraw = true; this._sides = v; },
      },
      sideIndent: {
        get: function() { return this._sideIndent; },
        set: function(v) { this._dirtyDraw = true; this._sideIndent = v; },
      },
    },
  });

});

phina.namespace(function() {
<span id='phina-display-PolygonShape'>  /**
</span>   * @class phina.display.PolygonShape
   *
   */
  phina.define(&#39;phina.display.PolygonShape&#39;, {
    superClass: &#39;phina.display.Shape&#39;,
    init: function(options) {
      options = (options || {}).$safe({
        backgroundColor: &#39;transparent&#39;,
        fill: &#39;cyan&#39;,
        stroke: &#39;#aaa&#39;,
        strokeWidth: 4,

        radius: 32,
        sides: 5,
      });
      this.superInit(options);

      this.setBoundingType(&#39;circle&#39;);
      this.sides = options.sides;
    },

    _render: function() {
      var size = this.radius*2 + this.padding*2;
      this._renderBackground(size, size);

      var canvas = this.canvas;

      canvas.transformCenter();

      if (this.fill) {
        canvas.context.fillStyle = this.fill;
        canvas.fillPolygon(0, 0, this.radius, this.sides);
      }

      if (this.stroke) {
        canvas.context.lineWidth = this.strokeWidth;
        canvas.strokeStyle = this.stroke;
        canvas.strokePolygon(0, 0, this.radius, this.sides);
      }
    },

    _accessor: {
      sides: {
        get: function() { return this._sides; },
        set: function(v) { this._dirtyDraw = true; this._sides = v; },
      },
    },
  });

});


phina.namespace(function() {
<span id='phina-display-HeartShape'>  /**
</span>   * @class phina.display.HeartShape
   *
   */
  phina.define(&#39;phina.display.HeartShape&#39;, {
    superClass: &#39;phina.display.Shape&#39;,
    init: function(options) {
      options = (options || {}).$safe({
        backgroundColor: &#39;transparent&#39;,
        fill: &#39;pink&#39;,
        stroke: &#39;#aaa&#39;,
        strokeWidth: 4,

        radius: 32,
        cornerAngle: 45,
      });
      this.superInit(options);

      this.setBoundingType(&#39;circle&#39;);
      this.cornerAngle = options.cornerAngle;
    },

    _render: function() {
      var size = this.radius*2 + this.padding*2;
      this._renderBackground(size, size);

      var canvas = this.canvas;

      canvas.transformCenter();

      if (this.fill) {
        canvas.context.fillStyle = this.fill;
        canvas.fillHeart(0, 0, this.radius, this.cornerAngle);
      }

      if (this.stroke) {
        canvas.context.lineWidth = this.strokeWidth;
        canvas.strokeStyle = this.stroke;
        canvas.strokeHeart(0, 0, this.radius, this.cornerAngle);
      }
    },

    _accessor: {
      cornerAngle: {
        get: function() { return this._cornerAngle; },
        set: function(v) { this._dirtyDraw = true; this._cornerAngle = v; },
      },
    },
  });

});
</pre>
</body>
</html>
